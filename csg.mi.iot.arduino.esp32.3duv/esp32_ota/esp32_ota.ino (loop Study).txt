void loop(void)
{
    // 1. 웹 서버 클라이언트 요청 처리
    server.handleClient();
    // 왜? ->
    // (1) 웹 서버 동작 유지: 이 함수를 주기적으로 호출해야 WebServer 라이브러리가 웹 브라우저로부터 들어오는 HTTP 요청(페이지 접속, 파일 업로드 등)을 감지하고, 
           이전에 설정된 server.on() 콜백 함수들을 실행할 수 있습니다.
    // (2) 실시간 웹 서비스: 이 코드가 loop() 안에 없다면, 웹 서버는 요청을 처리하지 못하고 장치는 웹에 반응하지 않을 겁니다. 
           사용자가 웹 페이지를 새로고침하거나 파일을 업로드할 때마다 loop()가 돌면서 이 함수가 실행되어야 합니다.

    // 2. MQTT 클라이언트 설정 (반복)
    client.setServer(MQTT_SERVER, MQTT_PORT);
    client.setCallback(mqttCallback);
    // 왜? ->
    // (1) 재확인 또는 재설정: 이 두 줄은 사실 setup() 함수에서 한 번만 설정해도 충분합니다. 하지만 loop() 안에 배치하면, 매 loop() 반복마다 MQTT 브로커 주소와 콜백 함수를 '재확인'하거나 '재설정'하게 됩니다.
    // (2) 견고성 (선택적): 만약 어떤 이유로 MQTT 클라이언트 설정이 중간에 손상되었을 경우를 대비한 방어적인 코드로 볼 수도 있지만, 일반적으로는 불필요한 오버헤드입니다.
       setup()에 한 번만 두는 것이 더 효율적입니다. 하지만 기능상 문제되지는 않습니다.

    // 3. Wi-Fi 및 MQTT 연결 상태 확인 및 재연결
    wifiStatus = WiFi.status(); // 현재 Wi-Fi 연결 상태를 확인하여 변수에 저장합니다.
    if (wifiStatus != WL_CONNECTED) // 만약 Wi-Fi가 연결되어 있지 않은 상태라면
    {
        reconnect_wifi(); // 미리 정의된 reconnect_wifi() 함수를 호출하여 Wi-Fi 재연결을 시도합니다.
    }
    if (!client.connected()) // 만약 MQTT 클라이언트가 브로커에 연결되어 있지 않은 상태라면
    {
        reconnect_mqtt(); // 미리 정의된 reconnect_mqtt() 함수를 호출하여 MQTT 재연결을 시도합니다.
    }
    // 왜? ->
    // (1) 연결 유지의 핵심: IoT 장치는 지속적으로 데이터를 전송해야 하므로, Wi-Fi와 MQTT 연결이 항상 활성화되어 있어야 합니다.
    // (2) 자동 복구: 네트워크는 불안정할 수 있으며, 연결이 끊어지는 상황이 발생할 수 있습니다. 이 코드는 그러한 경우 장치가 자동으로 연결을 감지하고 복구를 시도하여,
           수동 개입 없이도 장치의 서비스 지속성을 보장합니다.
    // (3) 우선순위: Wi-Fi 연결이 먼저 되어야 MQTT 연결이 가능하므로, Wi-Fi 재연결이 MQTT 재연결보다 먼저 검사됩니다.

    // 4. 센서 데이터 읽기 및 가공
    char *json = "{ \"sensor_id\":\"%s\", \"mW\": %3.8f}"; // MQTT로 보낼 JSON 문자열의 형식을 정의합니다. %s와 %3.8f는 값이 들어갈 자리입니다.
    float mw = (analogRead(A0) / 4095.0) * 500.0; // A0 핀에서 아날로그 센서 값을 읽어 밀리와트(mW) 값으로 변환합니다.
    // 왜? ->
    // (1) 센싱: 장치의 주된 목적 중 하나인 센서 데이터 수집을 수행합니다. A0 핀은 외부 아날로그 센서(예: 조도 센서, 진동 센서 등)가 연결될 수 있는 입력 포트입니다.
    // (2) 데이터 변환: analogRead(A0)는 ESP32의 ADC(아날로그-디지털 변환기)가 읽은 0~4095 범위의 원시 디지털 값입니다. 
           이를 0~500mW 범위의 물리적인 의미를 가진 값으로 스케일링하여 실제 '밀리와트'를 표현합니다. (나누기 4095.0, 곱하기 500.0으로 float 연산을 강제하여 정확도 확보)
    if (mw < 0) // 변환된 mW 값이 혹시라도 0보다 작으면
        mw = 0; // 0으로 강제로 설정합니다.
    // 왜? ->
    // (1) 데이터 유효성: 센서 값은 물리적인 측정치이므로, 음수 값이 나올 수 없습니다. 비정상적인 값을 필터링하여 데이터의 신뢰성을 높입니다.

    // 5. 센서 데이터 JSON 형식으로 변환 및 시리얼 출력
    snprintf(Sensor, SENSOR_BUFFER_SIZE, json, SENSOR_ID, mw); // 정의된 JSON 형식에 SENSOR_ID와 계산된 mw 값을 넣어 Sensor 버퍼에 최종 JSON 문자열을 생성합니다.
    Serial.println(Sensor); // 생성된 JSON 문자열을 시리얼 모니터에 출력합니다.
    Serial.print("ADC raw value : "); // 디버깅을 위해 ADC 원시 값임을 알리는 메시지 출력
    Serial.println(analogRead(A0)); // ADC의 원시 값도 시리얼 모니터에 다시 출력합니다.
    // 왜? ->
    // (1) 데이터 표준화: MQTT로 데이터를 보낼 때 JSON은 매우 일반적이고 표준적인 데이터 형식입니다. 클라우드 플랫폼이나 다른 애플리케이션이 이 데이터를 쉽게 파싱(분석)할 수 있도록 합니다.
    // (2) 개발/디버깅 용이: 시리얼 모니터에 JSON과 원시 ADC 값을 출력하여, 개발자가 센서가 제대로 작동하는지, 데이터 변환이 올바른지, 
           그리고 어떤 데이터가 MQTT로 전송될지 실시간으로 확인할 수 있도록 돕습니다.

    // 6. MQTT 통신 주기 처리 및 데이터 발행
    client.loop(); // MQTT 클라이언트 라이브러리의 주기적인 작업을 처리합니다.
    // 왜? ->
    // (1) MQTT 연결 유지: 이 함수는 MQTT 브로커와의 연결을 활성 상태로 유지하고, 주기적으로 keep-alive 패킷을 교환하며, 
          혹시 수신할 메시지가 있는지 확인하는 등 MQTT 통신의 백그라운드 작업을 수행합니다. loop() 안에서 지속적으로 호출되어야 합니다.
    // (2) 메시지 수신 처리: 만약 구독한 토픽으로 메시지가 도착했다면, 이 함수가 mqttCallback() 함수를 호출하여 메시지를 처리합니다.
          client.publish(OutTopic, Sensor); // 생성된 JSON 센서 데이터(Sensor)를 고유한 OutTopic으로 MQTT 브로커에 발행(Publish)합니다.
    // 왜? ->
    // (1) 데이터 전송: 이 장치의 핵심 기능인 센서 데이터를 클라우드나 다른 시스템으로 전송하는 명령입니다.
           이 명령을 통해 장치가 "내가 측정한 이 데이터를 브로커에게 보낼게!"라고 요청하는 것입니다.

    // 7. 다음 주기까지 대기
    delay(1000); // 1000 밀리초(1초) 동안 프로그램 실행을 일시 정지합니다.
    // 왜? ->
    // (1) 주기 제어: 센서 데이터를 너무 빠르게 보내는 것을 방지하여, MQTT 브로커에 부담을 줄이고 데이터 전송 간격을 일정하게 유지합니다. (초당 1회 전송)
    // (2) 자원 절약: 불필요하게 CPU를 계속 사용하지 않고 잠시 쉬게 하여, 전력 소모를 줄이고 다른 내부 작업(예: Wi-Fi 백그라운드 작업)이 원활하게 수행될 수 있도록 여유를 줍니다.
    // (3) 안정성: 너무 빠른 루프는 때때로 시스템을 불안정하게 만들 수 있습니다. 적절한 딜레이는 필요

최종 목적과 코드의 연결고리
여러분이 올려주신 코드를 통해 mW 값이 원격으로 어떻게 확인되고 저장될 수 있는지 그 연결고리는 다음과 같습니다:

센서 값 측정: loop() 함수에서 analogRead(A0)를 통해 물리적인 센서 값을 측정하고, 이를 mW 값으로 변환합니다. (float mw = (analogRead(A0) / 4095) * 500;)
JSON 포맷으로 가공: 측정된 mW 값은 {"sensor_id":"%s", "mW": %3.8f} 형태의 JSON 문자열로 깔끔하게 포장됩니다. 이 형태는 컴퓨터가 이해하기 쉽고 다른 시스템으로 전송하기에 표준적입니다.
MQTT를 통한 원격 전송: 가공된 JSON 데이터는 client.publish(OutTopic, Sensor); 명령을 통해 MQTT 브로커로 발행됩니다. 이 MQTT 브로커는 대개 클라우드 서버나 원격 서버에 위치합니다.
원격 확인 및 저장:
확인: 여러분은 인터넷이 연결된 어디서든 MQTT 클라이언트 프로그램을 사용하거나, MQTT 브로커와 연동된 클라우드 대시보드에 접속하여 해당 OutTopic을 구독하면,
ESP32가 보내는 mW 값을 실시간으로 볼 수 있습니다.
저장: MQTT 브로커는 보통 클라우드 데이터베이스(예: AWS DynamoDB, Google Cloud Firestore)나 다른 데이터 저장 서비스와 연동되어 있습니다.
장치에서 보낸 mW 값은 이 브로커를 통해 자동으로 데이터베이스에 저장되어 나중에 분석하거나 시각화하는 데 사용될 수 있습니다.
요약
Serial.begin()을 통한 시리얼 모니터링은 개발 단계에서 장치의 동작을 눈으로 확인하고 디버깅하기 위한 도구이지만, 
이 장치의 궁극적인 목적은 Wi-Fi와 MQTT를 사용하여 센서(mW) 데이터를 원격으로 수집하고 활용하는 것입니다. 
이를 통해 데이터를 실시간으로 모니터링하거나 장기간 저장하여 분석하는 등 다양한 IoT 애플리케이션을 구현할 수 있습니다.